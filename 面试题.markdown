# 计算机网络分层体系结构（五层举例）

应用层：为应用程序提供交互服务，DNS，DHCP，HTTP等

传输层：在两台主机的进程之间提供数据传输服务，包括UDP和TCP

网络层：在不同网络间传播数据，通过IP协议解决寻址和路由的问题

数据链路层：在一段链路间传播数据

物理层：解决比特流传输的问题

# 三次握手

1. 客户端的TCP进程向服务器的TCP进程发送标志位为SYN=1的TCP连接请求，当然ACK报文里还包括随机生成的客户端序列号seq
2. 服务器的TCP进程收到请求后，响应一个标志位为SYN=1，ACK=1的TCP响应报文，报文里还包含服务器序列号seq和确认号ack，那是它期待从客户端接收的第一个字节序列号
3. 客户端的TCP进程收到响应后，回返回一个ACK=1的确认报文，序列号seq就是服务器发送的ack，而确认号ack就是服务器序列号+1

# 四次挥手

1. **主动关闭方完成数据发送**：主动结束方发送标志位FIN=1的TCP报文，表示已经没有数据继续传输了，进入到FIN-WAIT-1状态
2. **被动关闭方接收FIN并确认**：被动结束方收到报文后，发送一个ACK确认报文，表示接收到结束请求，进入CLOSE-WAIT状态。被动结束方会继续发送数据。而主动关闭方会进入到FIN-WAIT-2状态
3. **被动关闭方发送FIN**：当被动关闭方也完成数据发送后，它发送自己的FIN报文给主动关闭方，请求关闭其到主动关闭方的连接。
4. **主动关闭方确认被动关闭方的FIN**：主动关闭方接收到被动关闭方的FIN报文后，发送一个ACK确认，并进入TIME-WAIT状态
5. **等待2MSL**：在发送了对被动关闭方FIN的ACK之后，主动关闭方等待2MSL时间。这个等待确保被动关闭方接收到了最终的确认，并且确保网络上所有可能的延迟报文都已消失。

**四次挥手的必要性：**

- 确保数据传输完成：四次挥手允许TCP连接在两个方向上独立关闭。这意味着发送方可以完成它的数据发送，而接收方也可以完成它的数据接收。
- 防止旧连接的影响：2MSL等待确保所有旧的重复数据包都从网络中消失，防止它们干扰新的连接。
- 确认连接关闭：四次挥手确保双方都接收到了对方的关闭请求，并发送了确认，这样连接才能安全关闭。
- 防止资源浪费：如果使用三次挥手，那么在连接关闭时，如果一方已经关闭连接而另一方还有数据发送，这可能导致资源浪费和数据丢失。
- 有序关闭：四次挥手允许双方独立地关闭连接，这有助于避免连接的一端在没有接收到所有数据的情况下被提前关闭

![image.png](assets/ima11ge.png)

# 为什么不是两次握手

1. 第三次握手可以确认客户端是可以接收服务器报文的能力
2. 防止重复连接请求。如果重复发送的TCP连接建立请求在一段时间后才被服务器接收，就会在客户端和服务器端建立连接，但此时已经存在连接了

# 四次挥手中为什么等待2MSL

**防止旧连接的影响**：如果连接过早关闭，那么之前发送的数据包可能会在网络中延迟，并在新的连接中被错误地接收。2MSL等待确保所有旧连接的数据包都已从网络中消失，防止它们干扰新的连接

**允许足够的时间进行超时重传**：如果接收方因为某些原因没有及时发送确认（ACK），发送方可能会触发超时重传机制。2MSL等待确保发送方有足够的时间进行必要的重传

# TCP 如何保证可靠传输

TCP（传输控制协议）通过多种机制来保证数据的可靠传输，以下是TCP确保可靠性的关键特性：

1. **数据包编号**：TCP给每个字节的数据包分配一个序列号，确保数据能够按照发送顺序被接收
2. **确认应答（ACK）**：接收方会发送确认应答给发送方，告知已成功接收到的数据包
3. **超时重传**：如果发送方在一定时间内没有收到确认应答，它会重传数据包
4. **流量控制**：TCP使用滑动窗口协议来控制发送方的数据发送速率，以匹配接收方的处理能力，防止接收方被大量数据淹没
5. **拥塞控制**：TCP动态调整数据的发送速率以避免网络拥塞，拥塞控制算法会根据网络状况调整窗口大小
6. **连接管理**：TCP通过三次握手过程建立连接，并在数据传输结束后通过四次挥手过程释放连接，确保数据传输的开始和结束都是可靠的
7. **最大报文段生存时间（MSL）**：TCP定义了报文段的最大生存时间，超时未确认的报文会被重传，2MSL等待确保所有重复的报文段都从网络中消失
8. **keepalive**：TCP使用保活定时器和探测报文来检测连接的有效性，如果连接已经断开或对方不再可达，TCP会重新尝试建立连接或通知应用层

# TCP流量控制（滑动窗口机制）

TCP流量控制主要通过滑动窗口机制来实现，其目的是防止发送方过快地发送数据，导致接收方来不及处理而造成数据丢失

1. **窗口大小（Window Size）**：在TCP连接建立时，接收方会告知发送方其接收缓冲区的大小，即窗口大小。这个窗口大小是接收方能够处理的最大数据量。
2. **滑动窗口**：发送方维护一个滑动窗口，该窗口表示接收方当前能够接收的数据范围。窗口的左边界是已确认接收的数据的最后一个字节，右边界是未确认但可接收的数据的最后一个字节。
3. **数据发送**：发送方只能发送窗口内的数据。当接收方确认收到数据后，窗口会向右滑动，表示接收方已为新数据腾出空间。
4. **动态调整**：接收方会根据其处理能力和缓冲区大小动态调整窗口大小，并通过ACK报文通知发送方新的窗口大小。
5. **流量控制**：如果接收方的缓冲区快满了，它可以减小窗口大小，甚至设置为0，告诉发送方暂时停止发送数据。发送方必须尊重接收方的窗口大小，并停止发送新的数据，直到接收方再次增加窗口大小。
6. **零窗口探测**：当接收方的窗口大小为0时，发送方会定期发送探测报文（通常是一个特殊的ACK报文），询问接收方是否可以开始发送数据。
7. **快速重传**：当接收方收到一个失序的数据包时，它会立即发送重复的ACK（即对同一个数据包的确认），而不是等待数据包的确认超时。发送方收到三个相同的ACK，会认为该数据包丢失，立即进行重传，而不必等待超时。

# TCP拥塞控制

一开始传输很小的数据量，逐渐探测，逐渐增加发送窗口。这个窗口也是动态变化的。

# HTTP和HTTPS的区别

**加密**：

- **HTTP**：在传输层不提供加密，数据以明文形式传输，可能会被中间人攻击者截获和篡改。
- **HTTPS**：在HTTP下加入了SSL/TLS协议，提供了数据加密、完整性校验和身份验证，确保数据传输的安全性。

**端口**：

- **HTTP**：默认使用80端口进行通信。
- **HTTPS**：默认使用443端口进行通信。

# 什么是数字证书

1. **身份验证**：当一个实体想要获得数字证书时，它首先向CA提交一个证书签名请求（CSR），其中包含实体的身份信息和公钥。
2. **审核过程**：CA会对实体的身份进行审核，这个过程可能包括验证法律文件、检查实体的注册信息等。
3. **证书生成**：身份验证通过后，CA会生成一个数字证书，将实体的公钥和身份信息打包在一起。
4. **数字签名**：CA用自己的私钥对生成的数字证书进行数字签名。
5. **证书颁发**：CA将签名后的数字证书颁发给实体。
6. **证书验证**：当其他实体（如浏览器或客户端应用程序）与持有证书的服务器通信时，它们可以使用CA的公钥来验证证书的数字签名，从而确认证书的真实性和服务器的身份。

用户访问服务器时的SSL/TLS握手过程确实涉及到证书的交换和验证，但不是服务器直接把自己的CA发送给用户。这个过程通常如下：

1. **客户端发起连接**：用户通过浏览器（客户端）发起对服务器的HTTPS请求。
2. **服务器发送证书**：服务器响应请求，发送其SSL/TLS证书给客户端。这个证书通常包含了服务器的公钥和身份信息，由一个受信任的CA签发。
3. **客户端验证证书**：客户端（浏览器）内置了一组受信任的CA的公钥（根证书）。客户端会使用这些公钥来验证服务器证书的有效性
4. **证书有效性**：如果证书验证通过，客户端会接受服务器的证书，并认为服务器的身份是可信的。
5. **密钥交换**：客户端和服务器使用服务器的公钥开始SSL/TLS握手过程，其中包括密钥交换算法，以生成一个会话密钥。
6. **加密通信**：一旦会话密钥生成，客户端和服务器将使用此密钥来加密和解密它们之间传输的数据。
7. **结束SSL/TLS握手**：完成握手后，客户端和服务器就可以开始加密的数据交换。
8. **客户端生成会话密钥**：一旦证书验证通过，客户端会生成一个随机的会话密钥，这个会话密钥将用于本次会话的加密通信。
9. **加密会话密钥**：客户端使用服务器证书中提供的公钥加密这个会话密钥。
10. **发送加密的会话密钥**：客户端将加密后的会话密钥发送给服务器。
11. **服务器解密会话密钥**：服务器使用自己的私钥解密收到的加密会话密钥，得到客户端生成的会话密钥。

# 对称加密和非对称加密

- 对称加密使用一对密钥进行加密和解密。客户端和服务器端最大的问题就是如何交换密钥。
- 非对称加密使用两对密钥，只会对外暴露公钥

在SSL/TLS中，非对称加密用于安全地交换对称密钥，然后使用对称加密来加密实际传输的数据。因为对称加密更快

# HTTPS工作流程

1. **用户请求**：
   用户在浏览器中输入一个以`https://`开头的URL，请求访问一个安全网站。
2. **服务器域名解析**：
   浏览器首先解析服务器的域名，将其转换为IP地址。
3. **建立TCP连接**：
   通过三路握手过程，客户端（用户的浏览器）和服务器之间建立一个TCP连接。
4. **发送HTTP请求**：
   一旦TCP连接建立，浏览器向服务器发送HTTP请求。
5. **服务器响应**：
   服务器接收到HTTP请求后，准备响应，并开始SSL/TLS握手过程。
6. **SSL/TLS握手**：

   - 服务器向客户端发送其SSL证书，该证书包含服务器的公钥和其他身份信息。
   - 客户端（浏览器）验证服务器证书的有效性，包括证书是否由受信任的CA签发，证书是否过期，以及证书的域名是否与请求的域名匹配。
7. **客户端生成会话密钥**：
   如果证书验证通过，客户端生成一个随机的会话密钥，这个会话密钥将用于加密实际传输的数据。
8. **加密会话密钥**：
   客户端使用服务器证书中的公钥加密会话密钥。
9. **发送加密的会话密钥**：
   客户端将加密后的会话密钥发送给服务器。
10. **服务器解密会话密钥**：
    服务器使用自己的私钥解密加密的会话密钥，得到客户端生成的会话密钥。
11. **建立加密通道**：
    客户端和服务器现在都有了相同的会话密钥，使用这个密钥来加密和解密它们之间传输的数据。
12. **加密数据传输**：
    使用会话密钥加密的数据在客户端和服务器之间传输。
13. **服务器处理请求**：
    服务器解密接收到的加密数据，处理用户的请求。
14. **发送加密响应**：
    服务器将响应数据加密后发送回客户端。
15. **客户端解密响应**：
    客户端解密服务器的响应，以便用户可以查看或与内容交互。
16. **关闭TCP连接**：
    数据传输完成后，通过TCP四次挥手过程关闭TCP连接。

# HTTP常见状态码

**200 OK**：请求成功，请求的网页已返回

**400 Bad Request**：服务器无法理解请求，请求无效。

**401 Unauthorized**：请求需要用户的身份验证。

**403 Forbidden**：服务器理解请求但拒绝执行。

**404 Not Found**：请求的资源在服务器上未找到。

**500 Internal Server Error**：服务器内部错误，无法完成请求

**503 Service Unavailable**：服务器目前无法使用（由于超载或停机维护）。

**504 Gateway Timeout**：网关超时

# HTTP长连接和短连接，流水线是什么

### HTTP长连接（Persistent Connections）

在HTTP/1.0中，默认情况下每次请求/响应后连接都会关闭，这被称为HTTP短连接。HTTP/1.1引入了持久连接（也称为长连接），其中TCP连接可以被重用，减少了连接建立和关闭的开销。

- **特点**：
  - 使用`Connection: keep-alive`头部标识连接保持活动状态。
  - 一个TCP连接可以传输多个HTTP请求和响应，直到客户端或服务器端明确关闭连接。
  - 减少了握手次数，提高了效率。

### HTTP短连接（Non-Persistent Connections）

- **特点**：
  - 每个请求/响应后，TCP连接都会关闭。
  - 每次通信都需要建立新的TCP连接，增加了连接建立的延迟。
  - 在HTTP/1.0中是默认行为，但可以通过`Connection: keep-alive`头部启用长连接。

### HTTP流水线（Pipelining）

HTTP流水线是HTTP/1.1的一个特性，它允许客户端在第一个请求没有得到响应之前，发送多个请求。

# HTTP版本区别（1.0，1.1，2.0）

### HTTP/1.0

- **连接**：默认使用非持久连接，每个请求/响应后连接关闭，但也可以通过`Connection: keep-alive`头部启用持久连接。
- **传输编码**：不支持传输编码，如分块传输。
- **Host头**：不要求Host头部，这可能导致发送到默认主机的请求。
- **缓存**：对缓存的控制较弱，没有引入实体标签（ETags）。
- **内容编码**：不支持多种内容编码，如gzip压缩。

### HTTP/1.1

- **持久连接**：默认支持持久连接，一个TCP连接可以传输多个HTTP请求和响应。
- **分块传输**：支持分块传输编码，允许发送方在知道整个响应内容大小之前就开始发送响应。
- **Host头**：要求Host头部，允许更精确的资源定位。
- **缓存控制**：引入了更多的缓存控制机制，如实体标签（ETags）和Last-Modified头。
- **内容编码**：支持多种内容编码，如gzip压缩。
- **管道化**：支持请求管道化（Pipelining），允许在单个连接上并行发送多个请求。
- **范围请求**：支持范围请求，可以请求资源的一部分。
- **安全性**：支持更多的安全性特性，如HTTPS和TLS

# GET和POST区别和应用

GET是幂等的，POST不是幂等的

POST的参数在请求体中，所以可以传输敏感参数

GET对传输数据的大小也有限制

GET请求可以被缓存，而POST不会被缓存

# 浏览器输入URL到页面返回详细过程

1. **解析URL**：

   - 浏览器首先解析输入的URL，确定其协议（如HTTP或HTTPS）、域名、端口（如果有）和路径。
2. **DNS查询**：

   - 如果浏览器缓存中没有域名对应的IP地址，它将向DNS服务器发起查询，以获取域名对应的IP地址。
3. **建立TCP连接**：

   - 浏览器使用得到的IP地址，通过三次握手过程与服务器建立TCP连接。
4. **发送HTTP请求**：

   - 一旦TCP连接建立，浏览器构建一个HTTP请求消息，并通过TCP连接发送给服务器。
5. **服务器处理请求**：

   - 服务器接收到HTTP请求后，会根据请求的类型（如GET或POST）和资源路径来处理请求。
6. **服务器响应**：

   - 服务器处理请求后，会发送一个HTTP响应消息，其中包含状态码、响应头和（如果有的话）响应体。
7. **关闭TCP连接**：

   - 如果是HTTP/1.0或请求中包含`Connection: close`头部，TCP连接在响应后关闭。如果是HTTP/1.1，并且包含`Connection: keep-alive`头部，TCP连接可以被重用。
8. **浏览器渲染页面

# Cookie和Session的区别

* **存储位置**：Cookie存储在客户端，Session存储在服务器端。
* **存储大小**：Cookie大小受限，Session大小相对更大。
* **有效期**：Cookie可以设置长期有效，Session通常与会话生命周期相关。
* **安全性**：Session比Cookie更安全，因为数据存储在服务器端。
* **传输**：Session ID需要在客户端和服务器之间传输，通常存储在Cookie中，也可以通过URL传递。

# 什么是ARP协议

ARP协议（地址解析协议，Address Resolution Protocol）是一种网络层协议，用于实现IPv4地址和MAC地址（媒体访问控制地址，也称为物理地址或以太网地址）之间的映射

### ARP协议的工作原理：

1. **地址解析**：当一台主机需要向同一局域网内的另一台主机发送数据时，它首先检查自己的ARP缓存（一个临时存储最近IP-MAC映射的表）中是否有目标IP地址对应的MAC地址。
2. **ARP请求**：如果ARP缓存中没有目标IP的映射信息，主机会发送一个ARP请求（也称为ARP广播），询问网络上的所有设备：“谁拥有IP地址X.X.X.X？请告诉我你的MAC地址。”
3. **ARP响应**：网络上的所有设备都会接收到ARP请求，但只有拥有目标IP地址的设备会响应该请求，并发送一个ARP响应，其中包含其MAC地址。
4. **ARP缓存更新**：发送ARP请求的主机接收到ARP响应后，会更新自己的ARP缓存，将目标IP地址与提供的MAC地址关联起来。
5. **数据传输**：一旦有了正确的MAC地址，主机就可以将数据封装在以太网帧中，并发送到局域网上的目的地。
6. **缓存过期**：为了节省内存资源，ARP缓存条目通常有生存时间（TTL）。过期后，如果再次需要相同的映射，将重新进行ARP请求过程。

# 什么是XSS攻击

XSS攻击（跨站脚本攻击，Cross-Site Scripting）是一种常见的网络安全攻击手段，它允许攻击者将恶意脚本注入到其他用户会浏览的网页中

**   使用ESAPI防止XSS的做法：**

String safe =ESAPI.encoder().encodeForHTML( request.getParameter( "input" ));

# DNS解析过程

DNS（域名系统，Domain Name System）解析过程是将人类可读的域名转换为机器可读的IP地址的过程。以下是DNS解析的一般步骤：

1. **浏览器缓存检查**：

   - 用户输入URL后，浏览器首先检查自身的缓存中是否有该域名对应的IP地址。
2. **操作系统缓存检查**：

   - 如果浏览器缓存中没有找到，浏览器会查询操作系统的DNS缓存。
3. **路由器缓存检查**：

   - 接下来，查询请求可能会被发送到本地网络的路由器，检查路由器的DNS缓存。
4. **ISP DNS缓存检查**：

   - 如果本地缓存中没有找到，请求会被发送到互联网服务提供商（ISP）的DNS服务器。
5. **递归查询**：

   - 如果ISP的DNS服务器缓存中也没有该记录，它会开始递归查询过程：
     - ISP的DNS服务器首先查询根域名服务器（Root Name Server, DNS Root Server）来找到负责顶级域名（TLD，如.com、.org）的域名服务器。
     - 然后，ISP的DNS服务器查询相应的TLD服务器（如.com域名服务器）以获取负责目标域名的权威名称服务器（Authoritative Name Server）的信息。
     - 最后，ISP的DNS服务器查询权威名称服务器以获取最终的IP地址。
6. **缓存IP地址**：

   - 一旦获得IP地址，ISP的DNS服务器会缓存这个地址，以响应后续的查询请求。
7. **返回IP地址**：

   - ISP的DNS服务器将查询到的IP地址返回给发起查询的客户端（用户的设备）。
8. **建立连接**：

   - 用户的设备得到IP地址后，可以通过IP地址与目标服务器建立TCP连接，并请求所需的网页数据。

# 谈谈IP地址和MAC地址

IP地址包含网络号和地址号，是一个网络设备的唯一标识

MAC地址是内嵌在网卡上，是网络接口的唯一标识

# HTTP请求转发和重定向的区别

HTTP请求转发（Forwarding）和重定向（Redirection）都是将客户端的请求发送到不同的地址以获取响应的手段，但它们的实现方式和用途有所不同：

### 请求转发

请求转发是一种服务器端的处理方式，客户端并不知道请求已经被转发到另一个服务器或资源。转发通常发生在Web服务器或应用服务器内部。

**特点**：

- **服务器端处理**：客户端的请求被服务器接收后，服务器将请求转发到另一个URL，处理完成后再将结果返回给客户端。
- **无额外请求**：对用户而言，这只是一个请求，他们不会感觉到请求被转发。
- **隐藏实际URL**：客户端不会看到转发后的URL，这有助于保护实际执行请求的资源位置。
- **安全性**：转发可以用于访问控制和安全性，例如，通过转发到后端服务而不是直接暴露服务地址。
- **请求保持**：原始请求中的所有信息（如headers、parameters等）都会被保留并转发到新地址。

### 重定向

重定向是HTTP协议的一部分，它指示客户端向不同的URL重新发送请求以获取响应。重定向是客户端可见的，因为客户端需要执行额外的请求。

**特点**：

- **客户端处理**：服务器响应客户端的请求时，返回一个特定的状态码（如301、302、303、307、308）和一个Location头部，指示客户端重新发送请求到新的URL。
- **额外请求**：重定向需要客户端进行额外的请求，这可能导致用户感知到的延迟。
- **显示新URL**：用户可以看到新的URL，这可能影响用户体验，尤其是在浏览器地址栏中。
- **用途多样**：重定向可用于URL重构、永久移动资源、临时移动资源、负载均衡等。
- **可能丢失信息**：在重定向过程中，原始请求中的某些信息（如POST数据）可能会丢失，除非是303 See Other响应，它要求客户端用GET方法重新发起请求。

### 总结

- **请求转发**：服务器端处理，客户端无感知，请求信息完整保留。
- **重定向**：客户端处理，客户端有感知，可能需要额外请求，可能丢失原始请求信息。

在实际应用中，选择使用请求转发还是重定向取决于具体需求。例如，内部服务器之间的请求处理通常使用转发，而需要通知客户端资源已移动的情况则使用重定向。

# 什么是DHCP协议

DHCP协议（动态主机配置协议，Dynamic Host Configuration Protocol）是一种网络协议，用于自动分配IP地址和其他网络配置参数给网络中的设备。DHCP使得设备在加入网络时能够获得所需的网络设置，而无需手动配置，这对于大型网络和动态网络环境非常有用。

### DHCP的主要功能包括：

1. **IP地址分配**：DHCP服务器为网络中的设备分配IP地址，确保每个设备都有一个唯一的地址。
2. **子网掩码分配**：提供子网掩码，帮助设备理解IP地址中网络部分和主机部分的划分。
3. **默认网关分配**：指定默认网关，即网络通信中用于连接本地网络和外部网络（如互联网）的设备地址。
4. **DNS服务器分配**：提供DNS服务器的IP地址，设备使用这些地址来解析域名和IP地址之间的映射。
5. **租约管理**：DHCP分配的IP地址通常是基于租约的，这意味着分配的地址在租约期满后可能会被回收或重新分配给其他设备。
6. **配置其他服务**：DHCP还可以提供其他网络服务的配置信息，如WINS服务器地址、时间服务器等。

# 粘包与拆包

### 粘包（Packet Merging）

- **定义**：粘包是指发送方发送的多个数据包在接收方接收时，由于TCP的流式传输特性，可能会被合并成一个大的数据包。
- **原因**：TCP在传输数据时，可能会将多个小的数据包合并为一个数据包进行传输，尤其是在数据发送频率较高或网络条件较好的情况下。
- **影响**：粘包会导致接收方难以确定原始的数据边界，从而增加了数据解析的复杂性。

### 拆包（Packet Splitting）

- **定义**：拆包是指发送方发送的一个大数据包在接收方接收时，被分割成多个小的数据包。
- **原因**：TCP在传输数据时，可能会根据网络条件和缓冲区大小将一个大的数据包分割成多个小的数据包进行传输。
- **影响**：拆包同样会导致接收方难以确定原始的数据边界，需要重新组装数据以恢复原始的发送内容。

### 解决粘包与拆包的方法：

1. **固定长度**：为每个数据包定义固定的长度，发送方和接收方都按照这个长度来发送和接收数据。
2. **分隔符**：在数据包之间使用特定的分隔符，这样接收方可以通过分隔符来识别数据包的边界。
3. **消息头**：在每个数据包的开始处添加一个消息头，消息头中包含数据包的长度或结束标志，这样接收方可以根据消息头来确定每个数据包的边界。
4. **超时机制**：设置一个超时时间，如果在超时时间内没有接收到足够的数据，则认为一个数据包已经接收完毕。
5. **流量控制**：通过TCP的流量控制机制，如滑动窗口，来控制发送方和接收方的数据传输速率，减少粘包和拆包的可能性。

# 如何理解HTTP协议的 “无连接，无状态” 特点？

无连接：每个HTTP请求都是独立的，不依赖于其他的请求和响应

无状态：HTTP服务器在处理请求时，不关心也不记录任何关于客户端状态的信息



为了解决无状态：有了session和cookie

# 说说TCP的重传机制

**超时重传**：当TCP发送一个数据段后，它会启动一个定时器，等待接收方确认（ACK）该数据段的接收。如果在预定的时间内没有收到确认，TCP会认为数据段在传输过程中丢失或损坏，并重新发送该数据段。

**快速重传**：当TCP接收方收到一个失序的数据段时（即序列号不是期望的下一个序列号），它会立即发送一个针对最近一个成功接收的数据段的确认（ACK）。这个确认是重复的，因为接收方已经收到并确认过这个数据段。如果发送方连续收到三个相同的ACK，这意味着接收方没有收到紧跟着最后一个成功接收数据段之后的数据段。发送方会认为这个数据段丢失了
